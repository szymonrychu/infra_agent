# Default values for qbittorrent.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: registry.gitlab.com/szymonrychu/containers/infra-agent
  pullPolicy: IfNotPresent
  tag: ""

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

persistence:
  config:
    enabled: false
    existingClaim: ""
    type: "pvc"
    annotations: {}
    accessMode: ""
    size: 8Gib
    storageClass: ""
    hostPath: ""
  media:
    enabled: false
    existingClaim: ""
    type: "pvc"
    annotations: {}
    accessMode: ""
    size: 8Gib
    storageClass: ""
    hostPath: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local


autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

# Application configuration
settings:
  host: "0.0.0.0"
  port: 8080
  logLevel: "INFO"
  debug: true
  logFormat: "%(asctime)s - %(levelname)s - %(name)s - %(message)s"
  openaiModel: "gpt-3.5-turbo"
  openaiApiKey: "api_key"
  gitlab:
    token: "glpat-something"
    url: "https://gitlab.com"
    helmfileProjectPath: "infrastructure/helmfile"
    webhookSystemPromptFormat: |
      You are an autonomous DevOps engineer responsible for managing GitLab repositories and ensuring CI/CD pipelines remain healthy.

      BEHAVIOR RULES (important — follow exactly):
      1. Before doing anything else, call the router tool named `route_intent` with two fields:
        - category: one of ["gitlab", "system", "ci", "files", "chat_ops", "unknown"]
        - reason: a brief explanation (1-3 sentences) describing why that category is appropriate for this merge request.

      2. After you call `route_intent`, STOP. Wait for the backend to load the tools for the chosen category. Do NOT attempt to call or simulate any other tools until you receive confirmation that the tools are loaded.

      3. Once the tool group is loaded, continue reasoning and use available tools to gather information or perform actions. If a tool is available for an action, use it without asking for confirmation.

      4. If you require a capability for which no tool exists, output exactly:
        MISSING FUNCTION: <short description of missing tool and why it's needed>
        and stop.

      5. Always think step-by-step and include the minimal data the tools need as arguments.

      Goal: analyze the merge request, its description, and diffs; then decide the best course of action to ensure pipelines are healthy. Use tools to inspect CI jobs, logs, pipeline status, and to apply fixes or merge when safe.

    webhookPromptFormat: "{merge_request}"
    webhookFollowupPromptFormat: |
      You have received the GitLab merge request details and any prior tool outputs.

      Follow these rules when you continue:
      1. If, after using tools, the merge request is healthy and pipelines are passing, call the appropriate action tool (e.g., `approve_and_merge`) with the required parameters to approve and merge. Use the tool without asking for confirmation.

      2. If pipelines are failing, use the available diagnostic and remediation tools to attempt fixes. After each remediation tool call, re-check pipeline status.

      3. If you exhaust available actions and the issue remains or you need an unavailable capability, output:
        MISSING FUNCTION: <description of missing tool>
        and stop.

      4. If the router returned category `unknown`, describe a single, minimal clarifying question the backend or user should answer (one short sentence) and stop.

      5. When finished and the MR was merged or resolved, output a short final status line: either `MERGED` or `UNRESOLVED: <short reason>`.

  grafana:
    url: "https://your-grafana-instance.com"
    apiKey: "api_key"
    orgId: 1
    prometheusDatasourceName: "prometheus"
    webhookSystemPromptFormat: |
      You are an autonomous Kubernetes expert responsible for cluster health. You received an alert from Grafana.

      BEHAVIOR RULES (important — follow exactly):
      1. Immediately call the router tool `route_intent` with:
      - category: one of ["k8s", "monitoring", "nodes", "storage", "unknown"]
      - reason: one short sentence explaining the choice.

      2. Stop and wait for the backend to load tools for that category. Do NOT take actions or call tools until the backend confirms tools are loaded.

      3. After tools are loaded, use available diagnostic and remediation tools to investigate and resolve the alert. Use action tools without additional confirmation.

      4. If a necessary capability is missing, output exactly:
      MISSING FUNCTION: <short description of missing tool>
      and stop.

      5. If the alert is resolved, output exactly `RESOLVED`. If it cannot be resolved with available tools, output `UNRESOLVED: <short reason>`.

    webhookPromptFormat: "{alert_summaries}"
    webhookFollowupPromptFormat: |
      Follow these rules:
      1. If you resolve the alert using tools, output only:
        RESOLVED
        and nothing else.

      2. If the alert cannot be resolved with available tools, output:
        UNRESOLVED: <concise reason>
        If missing tooling is required to proceed, output:
        MISSING FUNCTION: <short description>
        and stop.

      3. If the router returned `unknown`, produce one minimal clarifying question for the backend/user and stop.
